-- Umbrella_Linoria.lua
-- Merged adapter: Linoria widgets (AddToggle/AddSlider/AddDropdown/AddColorPicker/AddKeyPicker + Registry)
-- integrated into Umbrella style/layout.
-- Sources: Linoria.txt + Umbrella.txt
-- DO NOT EDIT unless you know what you do. Backup your Umbrella.txt.

-- ======= basic services (use Umbrella's existing services if available) =======
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local TextService = game:GetService("TextService")

local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer and LocalPlayer:GetMouse()

-- If Umbrella already defines API/global variables, try to reuse them:
local UmbrellaAPI = rawget(_G, "UmbrellaAPI") or rawget(_G, "API") or {}

-- Provide fallback ScreenGui (prefer Umbrella's main ScreenGui if exists)
local ScreenGui = UmbrellaAPI.ScreenGui or (LocalPlayer and LocalPlayer:FindFirstChild("PlayerGui") and Instance.new("ScreenGui") or Instance.new("ScreenGui"))
if not ScreenGui.Parent then
    ScreenGui.Name = "Umbrella_Linoria_ScreenGui"
    ScreenGui.ResetOnSpawn = false
    ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Global
    ScreenGui.Parent = game:GetService("CoreGui")
end

-- ======= Linoria-like Library (slimmed but functional) =======
local Library = {}
Library.Registry = {}
Library.RegistryMap = {}
Library.HudRegistry = {}
Library.Signals = {}
Library.ScreenGui = ScreenGui

Library.Font = Enum.Font.Code
Library.FontColor = Color3.fromRGB(255,255,255)
Library.MainColor = Color3.fromRGB(28,28,28)
Library.BackgroundColor = Color3.fromRGB(20,20,20)
Library.AccentColor = Color3.fromRGB(0,85,255)
Library.OutlineColor = Color3.fromRGB(50,50,50)
Library.AccentColorDark = (function(c) local h,s,v = Color3.toHSV(c); return Color3.fromHSV(h,s, math.max(v/1.5,0.1)) end)(Library.AccentColor)

-- util create
function Library:Create(Class, Props)
    local inst = (type(Class)=="string") and Instance.new(Class) or Class
    if Props then
        for k,v in pairs(Props) do
            pcall(function() inst[k] = v end)
        end
    end
    return inst
end

function Library:ApplyTextStroke(Inst)
    Inst.TextStrokeTransparency = 1
    local stroke = self:Create("UIStroke", {
        Color = Color3.new(0,0,0);
        Thickness = 1;
        LineJoinMode = Enum.LineJoinMode.Miter;
        Parent = Inst;
    })
end

function Library:AddToRegistry(Instance, Properties, IsHud)
    local Data = { Instance = Instance, Properties = Properties or {}, Idx = #Library.Registry + 1 }
    table.insert(Library.Registry, Data)
    Library.RegistryMap[Instance] = Data
    if IsHud then table.insert(Library.HudRegistry, Data) end
end

function Library:RemoveFromRegistry(Instance)
    local Data = Library.RegistryMap[Instance]
    if not Data then return end
    for i=#Library.Registry,1,-1 do
        if Library.Registry[i] == Data then table.remove(Library.Registry, i) end
    end
    for i=#Library.HudRegistry,1,-1 do
        if Library.HudRegistry[i] == Data then table.remove(Library.HudRegistry, i) end
    end
    Library.RegistryMap[Instance] = nil
end

function Library:SafeCallback(fn, ...)
    if not fn then return end
    local ok, err = pcall(fn, ...)
    if not ok then
        -- try to show Umbrella notification if exists
        if UmbrellaAPI and UmbrellaAPI.showNotification then
            pcall(UmbrellaAPI.showNotification, "UI callback error: "..tostring(err), "error", 3)
        end
    end
end

function Library:MouseIsOverOpenedFrame()
    for f,_ in pairs(Library.OpenedFrames or {}) do
        local AbsPos, AbsSize = f.AbsolutePosition, f.AbsoluteSize
        if Mouse.X >= AbsPos.X and Mouse.X <= AbsPos.X + AbsSize.X and Mouse.Y >= AbsPos.Y and Mouse.Y <= AbsPos.Y + AbsSize.Y then
            return true
        end
    end
    return false
end

-- keep tracking opened frames (for color picker / dropdown)
Library.OpenedFrames = {}

-- ======= Basic UI helpers (to match Umbrella layout) =======
local function MakeDraggable(instance, cutoff)
    instance.Active = true
    instance.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            local mouse = game:GetService("Players").LocalPlayer:GetMouse()
            local offset = Vector2.new(mouse.X - instance.AbsolutePosition.X, mouse.Y - instance.AbsolutePosition.Y)
            if offset.Y > (cutoff or 40) then return end
            while UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) do
                instance.Position = UDim2.new(0, mouse.X - offset.X + (instance.Size.X.Offset * instance.AnchorPoint.X),
                                          0, mouse.Y - offset.Y + (instance.Size.Y.Offset * instance.AnchorPoint.Y))
                RunService.RenderStepped:Wait()
            end
        end
    end)
end

-- ======= ADAPTER: integrate Linoria widget functions into Umbrella sections =======
-- Expect Umbrella's structure: API, modules, tabs, sections. We'll augment Section objects by adding Linoria-style methods.
-- We'll search for typical Umbrella API locations and patch them. If not found, create a simple Section helper.

local function findUmbrellaSectionsTable()
    -- common names seen in Umbrella: API, mainFrame, modules etc.
    if UmbrellaAPI and UmbrellaAPI.sections then
        return UmbrellaAPI.sections
    end
    -- try to find _G.mainFrame and sections inside it
    if _G and _G.mainFrame and _G.mainFrame:FindFirstChild("Content") then
        return {} -- fallback; we'll provide Section creation utility
    end
    return nil
end

-- Provide Section factory if Umbrella doesn't provide it
local Sections = {}
local function CreateSection(tabFrame, title)
    local Section = {}
    Section.Title = title or "Section"
    Section.Container = Library:Create("Frame", {
        BackgroundTransparency = 1;
        Size = UDim2.new(1,0,0,0);
        ZIndex = 1;
        Parent = tabFrame or ScreenGui;
    })
    Library:Create("UIListLayout", { Padding = UDim.new(0,4); FillDirection = Enum.FillDirection.Vertical; SortOrder = Enum.SortOrder.LayoutOrder; Parent = Section.Container })
    function Section:Resize() end -- placeholder
    Sections[#Sections+1] = Section
    return Section
end

-- Make sure we have a simple Tab/Section API if Umbrella doesn't provide
local function EnsureSection(obj)
    if obj and obj.AddToggle and obj.AddSlider then return obj end
    return CreateSection(obj, "Converted")
end

-- ======= Copy-in Linoria functions (essential ones) =======
-- We'll implement: AddToggle, AddSlider, AddDropdown, AddColorPicker, AddKeyPicker, AddInput (textbox)
-- Implementations are adapted directly from Linoria sources but made to attach into Section.Container.

-- AddToggle
local function Section_AddToggle(self, Info)
    assert(Info and Info.Text, "AddToggle: Missing Text")
    local Toggle = {
        Value = Info.Default or false,
        Type = "Toggle",
        Callback = Info.Callback,
        Addons = {}
    }

    local Container = self.Container
    -- outer frame
    local ToggleOuter = Library:Create("Frame", {
        BackgroundColor3 = Color3.new(0,0,0),
        BorderColor3 = Color3.new(0,0,0),
        Size = UDim2.new(1, -4, 0, 18),
        ZIndex = 5,
        Parent = Container,
    })

    local ToggleInner = Library:Create("Frame", {
        BackgroundColor3 = Library.MainColor,
        BorderColor3 = Library.OutlineColor,
        BorderMode = Enum.BorderMode.Inset,
        Size = UDim2.new(0, 13, 0, 13),
        Position = UDim2.new(0, 4, 0, 2),
        ZIndex = 6,
        Parent = ToggleOuter,
    })

    Library:AddToRegistry(ToggleInner, { BackgroundColor3 = "MainColor"; BorderColor3 = "OutlineColor" })

    local Label = Library:Create("TextLabel", {
        BackgroundTransparency = 1,
        Text = Info.Text,
        Font = Library.Font,
        TextSize = 14,
        TextColor3 = Library.FontColor,
        Position = UDim2.new(0, 26, 0, 0),
        Size = UDim2.new(1, -26, 1, 0),
        TextXAlignment = Enum.TextXAlignment.Left,
        ZIndex = 6,
        Parent = ToggleOuter,
    })
    Library:ApplyTextStroke(Label)
    Library:AddToRegistry(Label, { TextColor3 = "FontColor" })

    local function Display()
        ToggleInner.BackgroundColor3 = Toggle.Value and Library.AccentColor or Library.MainColor
        ToggleInner.BorderColor3 = Toggle.Value and Library.AccentColorDark or Library.OutlineColor
        Library.RegistryMap[ToggleInner].Properties.BackgroundColor3 = Toggle.Value and "AccentColor" or "MainColor"
        Library.RegistryMap[ToggleInner].Properties.BorderColor3 = Toggle.Value and "AccentColorDark" or "OutlineColor"
    end

    function Toggle:SetValue(val)
        Toggle.Value = not not val
        Display()
        Library:SafeCallback(Toggle.Callback, Toggle.Value)
    end

    ToggleOuter.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 and not Library:MouseIsOverOpenedFrame() then
            Toggle:SetValue(not Toggle.Value)
            -- best-effort save integration
            if UmbrellaAPI and UmbrellaAPI.AttemptSave then pcall(UmbrellaAPI.AttemptSave) end
        end
    end)

    Display()
    return Toggle
end

-- AddSlider
local function Section_AddSlider(self, Info)
    assert(Info and Info.Text and Info.Min ~= nil and Info.Max ~= nil and Info.Rounding ~= nil and Info.Default ~= nil, "AddSlider: missing params")
    local Slider = {
        Value = Info.Default,
        Min = Info.Min,
        Max = Info.Max,
        Rounding = Info.Rounding,
        Callback = Info.Callback,
        Type = "Slider"
    }

    local Container = self.Container
    local Outer = Library:Create("Frame", { BackgroundTransparency = 1, Size = UDim2.new(1, -4, 0, 28), ZIndex = 5, Parent = Container })
    local Label = Library:Create("TextLabel", { BackgroundTransparency = 1, Text = Info.Text.." ("..tostring(Slider.Value)..")", Font = Library.Font, TextSize = 14, TextColor3 = Library.FontColor, Size = UDim2.new(1,0,0,14), Parent = Outer })
    Library:ApplyTextStroke(Label)
    Library:AddToRegistry(Label, { TextColor3 = "FontColor" })

    local Bar = Library:Create("Frame", { BackgroundColor3 = Color3.fromRGB(50,50,50), Size = UDim2.new(1,0,0,8), Position = UDim2.new(0,0,0,16), Parent = Outer })
    Library:AddToRegistry(Bar, { BackgroundColor3 = "MainColor" })

    local Fill = Library:Create("Frame", { BackgroundColor3 = Library.AccentColor, Size = UDim2.new( (Slider.Value - Slider.Min)/(Slider.Max - Slider.Min), 0, 1, 0 ), ZIndex = 7, Parent = Bar })
    Library:AddToRegistry(Fill, { BackgroundColor3 = "AccentColor" })

    local dragging = false
    local function setValueFromX(x)
        local rel = math.clamp(x / Bar.AbsoluteSize.X, 0, 1)
        local val = Slider.Min + (Slider.Max - Slider.Min) * rel
        if Slider.Rounding > 0 then
            local fmt = "%."..tostring(Slider.Rounding).."f"
            val = tonumber(string.format(fmt, val))
        else
            val = math.floor(val)
        end
        Slider.Value = val
        Fill.Size = UDim2.new(rel, 0, 1, 0)
        Label.Text = Info.Text.." ("..tostring(Slider.Value)..")"
        Library:SafeCallback(Slider.Callback, Slider.Value)
    end

    Bar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            setValueFromX(math.clamp(Mouse.X - Bar.AbsolutePosition.X, 0, Bar.AbsoluteSize.X))
        end
    end)
    Bar.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then dragging = false end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            setValueFromX(math.clamp(Mouse.X - Bar.AbsolutePosition.X, 0, Bar.AbsoluteSize.X))
        end
    end)

    return Slider
end

-- AddInput (TextBox)
local function Section_AddInput(self, Info)
    assert(Info and Info.Text, "AddInput: missing text")
    local Container = self.Container
    local Label = Library:Create("TextLabel", { BackgroundTransparency = 1, Text = Info.Text, Font = Library.Font, TextSize = 14, TextColor3 = Library.FontColor, Parent = Container })
    Library:ApplyTextStroke(Label)
    Library:AddToRegistry(Label, { TextColor3 = "FontColor" })

    local Outer = Library:Create("Frame", { BackgroundColor3 = Library.MainColor, Size = UDim2.new(1,-4,0,26), ZIndex = 6, Parent = Container })
    Library:AddToRegistry(Outer, { BackgroundColor3 = "MainColor"; BorderColor3 = "OutlineColor" })
    local Box = Library:Create("TextBox", { BackgroundTransparency = 1, Text = Info.Default or "", Font = Library.Font, TextColor3 = Library.FontColor, TextSize = 14, Parent = Outer })
    Library:ApplyTextStroke(Box); Library:AddToRegistry(Box, { TextColor3 = "FontColor" })

    Box.FocusLost:Connect(function(enter)
        if enter then
            if Info.Callback then pcall(Info.Callback, Box.Text) end
        end
    end)

    return Box
end

-- AddDropdown
local function Section_AddDropdown(self, Info)
    assert(Info and Info.Values, "AddDropdown: missing Values")
    local Dropdown = { Values = Info.Values, Value = (Info.Multi and {}) or nil, Multi = Info.Multi, Callback = Info.Callback, Type = "Dropdown" }

    local Container = self.Container
    local Outer = Library:Create("Frame", { BackgroundTransparency = 1, Size = UDim2.new(1,-4,0,20), ZIndex = 5, Parent = Container })
    local ItemLabel = Library:Create("TextLabel", { BackgroundTransparency = 1, Text = Info.Text or "--", Font = Library.Font, TextSize = 14, TextColor3 = Library.FontColor, Parent = Outer })
    Library:ApplyTextStroke(ItemLabel); Library:AddToRegistry(ItemLabel, { TextColor3 = "FontColor" })

    -- dropdown list container (attached to ScreenGui)
    local ListOuter = Library:Create("Frame", { BackgroundColor3 = Library.MainColor, BorderColor3 = Library.OutlineColor, Visible = false, ZIndex = 50, Parent = Library.ScreenGui })
    Library:AddToRegistry(ListOuter, { BackgroundColor3 = "MainColor"; BorderColor3 = "OutlineColor" })
    local Scrolling = Library:Create("ScrollingFrame", { BackgroundTransparency = 1, Size = UDim2.new(0, Outer.AbsoluteSize.X, 0, 120), CanvasSize = UDim2.new(0,0,0,0), Parent = ListOuter })
    Library:Create("UIListLayout", { FillDirection = Enum.FillDirection.Vertical, Parent = Scrolling })

    local function buildList()
        for _,c in pairs(Scrolling:GetChildren()) do if not c:IsA("UIListLayout") then c:Destroy() end end
        for i, val in ipairs(Dropdown.Values) do
            local btn = Library:Create("TextLabel", { BackgroundTransparency = 1, Text = val, Font = Library.Font, TextColor3 = Library.FontColor, TextSize = 14, Size = UDim2.new(1,0,0,20), Parent = Scrolling })
            Library:ApplyTextStroke(btn); Library:AddToRegistry(btn, { TextColor3 = "FontColor" })
            btn.InputBegan:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 then
                    if Dropdown.Multi then
                        if Dropdown.Value[val] then Dropdown.Value[val] = nil else Dropdown.Value[val] = true end
                    else
                        Dropdown.Value = (Dropdown.Value==val) and nil or val
                        ListOuter.Visible = false
                        Library.OpenedFrames[ListOuter] = nil
                    end
                    if Dropdown.Callback then pcall(Dropdown.Callback, Dropdown.Value) end
                end
            end)
        end
        Scrolling.CanvasSize = UDim2.fromOffset(0, #Dropdown.Values * 20)
    end

    Outer.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 and not Library:MouseIsOverOpenedFrame() then
            if ListOuter.Visible then
                ListOuter.Visible = false; Library.OpenedFrames[ListOuter] = nil
            else
                ListOuter.Position = UDim2.fromOffset(Outer.AbsolutePosition.X, Outer.AbsolutePosition.Y + Outer.AbsoluteSize.Y + 2)
                ListOuter.Size = UDim2.fromOffset(Outer.AbsoluteSize.X, math.min(#Dropdown.Values*20, 160))
                ListOuter.Visible = true; Library.OpenedFrames[ListOuter] = true
                buildList()
            end
        end
    end)

    return Dropdown
end

-- AddColorPicker
local function Section_AddColorPicker(self, Info)
    assert(Info and Info.Default, "AddColorPicker: Missing default color")
    local ColorPicker = { Value = Info.Default, Transparency = Info.Transparency or 0, Callback = Info.Callback, Type = "ColorPicker" }

    local Container = self.Container
    local DisplayFrame = Library:Create("Frame", { BackgroundColor3 = ColorPicker.Value, BorderColor3 = Library:GetDarkerColor and Library:GetDarkerColor(ColorPicker.Value) or Color3.new(0,0,0), Size = UDim2.new(0,28,0,14), ZIndex = 6, Parent = Container })
    Library:AddToRegistry(DisplayFrame, { BackgroundColor3 = "MainColor"; BorderColor3 = "OutlineColor" })

    -- minimal full picker: spawn a small picker window (simple hue slider + satvib area) on click
    local PickerWindow = Library:Create("Frame", { BackgroundColor3 = Library.BackgroundColor, BorderColor3 = Library.OutlineColor, Size = UDim2.new(0,220,0,220), Visible = false, ZIndex = 60, Parent = Library.ScreenGui })
    Library:AddToRegistry(PickerWindow, { BackgroundColor3 = "BackgroundColor"; BorderColor3 = "OutlineColor" })

    DisplayFrame.InputBegan:Connect(function(inp)
        if inp.UserInputType == Enum.UserInputType.MouseButton1 and not Library:MouseIsOverOpenedFrame() then
            PickerWindow.Position = UDim2.fromOffset(DisplayFrame.AbsolutePosition.X, DisplayFrame.AbsolutePosition.Y + 18)
            PickerWindow.Visible = not PickerWindow.Visible
            Library.OpenedFrames[PickerWindow] = PickerWindow.Visible and true or nil
        end
    end)

    -- Very small/simple picker: allow user to paste hex in a TextBox
    local HexBox = Library:Create("TextBox", { Text = "#" .. ColorPicker.Value:ToHex(), BackgroundTransparency = 1, Font = Library.Font, TextColor3 = Library.FontColor, TextSize = 14, Size = UDim2.new(1,-8,0,20), Position = UDim2.new(0,4,0,4), Parent = PickerWindow })
    Library:ApplyTextStroke(HexBox); Library:AddToRegistry(HexBox, { TextColor3 = "FontColor" })

    HexBox.FocusLost:Connect(function(enter)
        if not enter then return end
        local success, col = pcall(function() return Color3.fromHex(HexBox.Text:gsub("#","")) end)
        if success and typeof(col) == "Color3" then
            ColorPicker.Value = col
            DisplayFrame.BackgroundColor3 = col
            if ColorPicker.Callback then pcall(ColorPicker.Callback, ColorPicker.Value) end
        end
    end)

    return ColorPicker
end

-- KeyPicker (basic)
local function Section_AddKeyPicker(self, Info)
    assert(Info and Info.Default, "AddKeyPicker: Missing default")
    local KeyPicker = { Value = Info.Default, Mode = Info.Mode or "Toggle", Callback = Info.Callback, Type = "KeyPicker" }

    local Container = self.Container
    local PickOuter = Library:Create("Frame", { Size = UDim2.new(0,80,0,18), BackgroundColor3 = Library.MainColor, BorderColor3 = Library.OutlineColor, Parent = Container })
    Library:AddToRegistry(PickOuter, { BackgroundColor3 = "MainColor"; BorderColor3 = "OutlineColor" })

    local Label = Library:Create("TextLabel", { Text = KeyPicker.Value, BackgroundTransparency = 1, Font = Library.Font, TextColor3 = Library.FontColor, ZIndex = 8, Parent = PickOuter })
    Library:ApplyTextStroke(Label); Library:AddToRegistry(Label, { TextColor3 = "FontColor" })

    local picking = false
    PickOuter.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 and not Library:MouseIsOverOpenedFrame() then
            picking = true
            Label.Text = "..."
            local conn
            conn = UserInputService.InputBegan:Connect(function(i)
                if not picking then return end
                local keyName = (i.UserInputType == Enum.UserInputType.Keyboard) and i.KeyCode.Name or (i.UserInputType == Enum.UserInputType.MouseButton1 and "MB1") or (i.UserInputType == Enum.UserInputType.MouseButton2 and "MB2") or tostring(i.UserInputType)
                KeyPicker.Value = keyName
                Label.Text = keyName
                Library:SafeCallback(KeyPicker.Callback, KeyPicker.Value)
                picking = false
                conn:Disconnect()
            end)
        end
    end)

    return KeyPicker
end

-- Add functions to Section metatable / object
local function AttachLinoriaAPIToSection(section)
    section = EnsureSection(section)
    section.AddToggle = function(_, info) return Section_AddToggle(section, info) end
    section.AddSlider = function(_, info) return Section_AddSlider(section, info) end
    section.AddDropdown = function(_, info) return Section_AddDropdown(section, info) end
    section.AddColorPicker = function(_, info) return Section_AddColorPicker(section, info) end
    section.AddKeyPicker = function(_, info) return Section_AddKeyPicker(section, info) end
    section.AddInput = function(_, info) return Section_AddInput(section, info) end
    return section
end

-- ======= Try to auto-patch Umbrella if possible =======
if UmbrellaAPI and UmbrellaAPI.CreateSection then
    -- Patch Umbrella sections so AddX methods available
    local oldCreateSection = UmbrellaAPI.CreateSection
    UmbrellaAPI.CreateSection = function(...)
        local sec = oldCreateSection(...)
        AttachLinoriaAPIToSection(sec)
        return sec
    end
end

-- Expose helper for manual use:
local Adapter = {}
Adapter.Attach = AttachLinoriaAPIToSection
Adapter.CreateSection = CreateSection
Adapter.Library = Library
Adapter.UmbrellaAPI = UmbrellaAPI

-- Put into _G for easy access
_G.Umbrella_Linoria = Adapter

return Adapter
